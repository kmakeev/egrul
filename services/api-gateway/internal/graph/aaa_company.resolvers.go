package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

// This file contains resolvers for Company type fields that require additional data loading

import (
	"context"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/egrul-system/services/api-gateway/internal/graph/model"
	"go.uber.org/zap"
)

// Founders is the resolver for the founders field on Company.
func (r *companyResolver) Founders(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.Founder, error) {
	r.Logger.Info("Founders resolver called", zap.String("ogrn", obj.Ogrn))
	
	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	// –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å DataLoader (per-request cache)
	if loader := foundersLoaderFromContext(ctx); loader != nil {
		founders, err := loader.Load(ctx, obj.Ogrn, l, o)
		if err != nil {
			r.Logger.Error("failed to get founders via dataloader", zap.String("ogrn", obj.Ogrn), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("Founders loaded via dataloader", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
		return founders, nil
	}

	// Fallback –∫ –ø—Ä—è–º–æ–º—É –≤—ã–∑–æ–≤—É —Å–µ—Ä–≤–∏—Å–∞
	founders, err := r.CompanyService.GetFounders(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	r.Logger.Info("Founders loaded directly", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
	return founders, nil
}

// Licenses is the resolver for the licenses field on Company.
func (r *companyResolver) Licenses(ctx context.Context, obj *model.Company) ([]*model.License, error) {
	licenses, err := r.CompanyService.GetLicenses(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get licenses", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return licenses, nil
}

// Branches is the resolver for the branches field on Company.
func (r *companyResolver) Branches(ctx context.Context, obj *model.Company) ([]*model.Branch, error) {
	branches, err := r.CompanyService.GetBranches(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get branches", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return branches, nil
}

// History is the resolver for the history field on Company.
func (r *companyResolver) History(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	// –ü–æ–ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ GraphQL –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
	fc := graphql.GetFieldContext(ctx)
	var l, o int = 50, 0
	
	r.Logger.Error("üî• CRITICAL DEBUG - History resolver called", 
		zap.String("ogrn", obj.Ogrn),
		zap.Any("limit_ptr", limit),
		zap.Any("offset_ptr", offset),
		zap.Bool("limit_is_nil", limit == nil),
		zap.Bool("offset_is_nil", offset == nil),
		zap.Any("field_context", fc),
	)
	
	// –ü—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ GraphQL
	if fc != nil && fc.Args != nil {
		r.Logger.Info("üîç Checking GraphQL field context args", zap.Any("args", fc.Args))
		
		if limitArg, ok := fc.Args["limit"]; ok && limitArg != nil {
			if limitPtr, ok := limitArg.(*int); ok && limitPtr != nil {
				l = *limitPtr
				r.Logger.Info("‚úÖ Extracted limit from GraphQL context", zap.Int("limit", l))
			}
		}
		
		if offsetArg, ok := fc.Args["offset"]; ok && offsetArg != nil {
			if offsetPtr, ok := offsetArg.(*int); ok && offsetPtr != nil {
				o = *offsetPtr
				r.Logger.Info("‚úÖ Extracted offset from GraphQL context", zap.Int("offset", o))
			}
		}
	}
	
	// Fallback –∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º —Ñ—É–Ω–∫—Ü–∏–∏
	if limit != nil {
		l = *limit
		r.Logger.Info("‚úÖ Using limit from function parameter", zap.Int("limit", l))
	}
	
	if offset != nil {
		o = *offset
		r.Logger.Info("‚úÖ Using offset from function parameter", zap.Int("offset", o))
	}

	r.Logger.Info("üîç Final parameters for CompanyService.GetHistory", 
		zap.String("ogrn", obj.Ogrn), 
		zap.Int("final_limit", l), 
		zap.Int("final_offset", o))
		
	history, err := r.CompanyService.GetHistory(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get history", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	
	r.Logger.Info("üìä History loaded successfully", 
		zap.String("ogrn", obj.Ogrn), 
		zap.Int("requested_limit", l), 
		zap.Int("requested_offset", o), 
		zap.Int("returned_count", len(history)),
		zap.String("first_grn", func() string {
			if len(history) > 0 { return history[0].Grn }
			return "none"
		}()),
		zap.String("last_grn", func() string {
			if len(history) > 0 { return history[len(history)-1].Grn }
			return "none"
		}()),
	)
	return history, nil
}

// HistoryCount is the resolver for the historyCount field on Company.
func (r *companyResolver) HistoryCount(ctx context.Context, obj *model.Company) (int, error) {
	r.Logger.Info("HistoryCount resolver called", zap.String("ogrn", obj.Ogrn))
	
	count, err := r.CompanyService.GetHistoryCount(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get history count", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return 0, err
	}
	r.Logger.Info("HistoryCount loaded", zap.String("ogrn", obj.Ogrn), zap.Int("count", count))
	return count, nil
}

// RelatedCompanies is the resolver for the relatedCompanies field on Company.
func (r *companyResolver) RelatedCompanies(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.RelatedCompany, error) {
	r.Logger.Info("RelatedCompanies resolver called", zap.String("ogrn", obj.Ogrn))
	
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	var relatedCompanies []*model.RelatedCompany

	// 1. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏-—É—á—Ä–µ–¥–∏—Ç–µ–ª–∏ (—é—Ä–∏–¥–∏—á–µ—Å–∫–∏–µ –ª–∏—Ü–∞ –≤ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è—Ö)
	founderCompanies, err := r.CompanyService.GetFounderCompanies(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get founder companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range founderCompanies {
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeFounderCompany,
				Description:      stringPtr("–ö–æ–º–ø–∞–Ω–∏—è-—É—á—Ä–µ–¥–∏—Ç–µ–ª—å"),
			})
		}
	}

	// 2. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º–∏ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è–º–∏-—Ñ–∏–∑–ª–∏—Ü–∞–º–∏
	commonFounderCompanies, err := r.CompanyService.GetCompaniesWithCommonFounders(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonFounderCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—â–∏—Ö —É—á—Ä–µ–¥–∏—Ç–µ–ª—è—Ö
			commonFounders, err := r.CompanyService.GetCommonFoundersDetails(ctx, obj.Ogrn, company.Ogrn)
			if err != nil {
				r.Logger.Warn("failed to get common founders details", 
					zap.String("ogrn1", obj.Ogrn), 
					zap.String("ogrn2", company.Ogrn), 
					zap.Error(err))
				commonFounders = []*model.Founder{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}
			
			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –∏–º–µ–Ω–∞–º–∏ –æ–±—â–∏—Ö —É—á—Ä–µ–¥–∏—Ç–µ–ª–µ–π
			description := "–û–±—â–∏–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏-—Ñ–∏–∑–ª–∏—Ü–∞"
			if len(commonFounders) > 0 {
				var names []string
				for _, founder := range commonFounders {
					if len(names) >= 3 { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 3 –∏–º–µ–Ω –≤ –æ–ø–∏—Å–∞–Ω–∏–∏
						names = append(names, "...")
						break
					}
					
					// –§–æ—Ä–º–∏—Ä—É–µ–º –§–ò–û —Å –ò–ù–ù
					var fullName string
					if founder.LastName != nil && founder.FirstName != nil {
						fullName = *founder.LastName + " " + *founder.FirstName
						if founder.MiddleName != nil && *founder.MiddleName != "" {
							fullName += " " + *founder.MiddleName
						}
					} else {
						fullName = founder.Name
					}
					
					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if founder.Inn != nil && *founder.Inn != "" {
						fullName += " (–ò–ù–ù: " + *founder.Inn + ")"
					}
					
					names = append(names, fullName)
				}
				
				if len(names) > 0 {
					description = "–û–±—â–∏–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏: " + strings.Join(names, ", ")
				}
			}
			
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonFounders,
				Description:      stringPtr(description),
				CommonFounders:   commonFounders,
			})
		}
	}

	// 2.5. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º–∏ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º–∏-—Ñ–∏–∑–ª–∏—Ü–∞–º–∏
	commonDirectorCompanies, err := r.CompanyService.GetCompaniesWithCommonDirectors(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common directors", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonDirectorCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—â–∏—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è—Ö
			commonDirectors, err := r.CompanyService.GetCommonDirectorsDetails(ctx, obj.Ogrn, company.Ogrn)
			if err != nil {
				r.Logger.Warn("failed to get common directors details", 
					zap.String("ogrn1", obj.Ogrn), 
					zap.String("ogrn2", company.Ogrn), 
					zap.Error(err))
				commonDirectors = []*model.Person{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}
			
			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –∏–º–µ–Ω–∞–º–∏ –æ–±—â–∏—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π
			description := "–û–±—â–∏–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏-—Ñ–∏–∑–ª–∏—Ü–∞"
			if len(commonDirectors) > 0 {
				var names []string
				for _, director := range commonDirectors {
					if len(names) >= 3 { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 3 –∏–º–µ–Ω –≤ –æ–ø–∏—Å–∞–Ω–∏–∏
						names = append(names, "...")
						break
					}
					
					// –§–æ—Ä–º–∏—Ä—É–µ–º –§–ò–û —Å –ò–ù–ù
					var fullName string
					if director.LastName != "" && director.FirstName != "" {
						fullName = director.LastName + " " + director.FirstName
						if director.MiddleName != nil && *director.MiddleName != "" {
							fullName += " " + *director.MiddleName
						}
					}
					
					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if director.Inn != nil && *director.Inn != "" {
						fullName += " (–ò–ù–ù: " + *director.Inn + ")"
					}
					
					if fullName != "" {
						names = append(names, fullName)
					}
				}
				
				if len(names) > 0 {
					description = "–û–±—â–∏–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏: " + strings.Join(names, ", ")
				}
			}
			
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonDirectors,
				Description:      stringPtr(description),
				CommonDirectors:  commonDirectors,
			})
		}
	}

	// 3. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏, –≥–¥–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ —è–≤–ª—è—é—Ç—Å—è —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º–∏
	founderToDirectorCompanies, err := r.CompanyService.GetCompaniesWhereFounderIsDirector(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies where founder is director", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range founderToDirectorCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω—ã—Ö —Å–≤—è–∑—è—Ö
			crossPersons, err := r.CompanyService.GetCrossPersonDetails(ctx, obj.Ogrn, company.Ogrn, "founder_to_director")
			if err != nil {
				r.Logger.Warn("failed to get cross person details", 
					zap.String("ogrn1", obj.Ogrn), 
					zap.String("ogrn2", company.Ogrn), 
					zap.Error(err))
				crossPersons = []*model.Person{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}
			
			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
			description := "–£—á—Ä–µ–¥–∏—Ç–µ–ª—å ‚Üí –†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å"
			if len(crossPersons) > 0 {
				var names []string
				for _, person := range crossPersons {
					if len(names) >= 3 {
						names = append(names, "...")
						break
					}
					
					var fullName string
					if person.LastName != "" && person.FirstName != "" {
						fullName = person.LastName + " " + person.FirstName
						if person.MiddleName != nil && *person.MiddleName != "" {
							fullName += " " + *person.MiddleName
						}
					}
					
					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if person.Inn != nil && *person.Inn != "" {
						fullName += " (–ò–ù–ù: " + *person.Inn + ")"
					}
					
					if fullName != "" {
						names = append(names, fullName)
					}
				}
				
				if len(names) > 0 {
					description = "–£—á—Ä–µ–¥–∏—Ç–µ–ª—å ‚Üí –†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å: " + strings.Join(names, ", ")
				}
			}
			
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeFounderToDirector,
				Description:      stringPtr(description),
				CommonDirectors:  crossPersons, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–µ CommonDirectors –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
			})
		}
	}

	// 4. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏, –≥–¥–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ —è–≤–ª—è–µ—Ç—Å—è —É—á—Ä–µ–¥–∏—Ç–µ–ª–µ–º
	directorToFounderCompanies, err := r.CompanyService.GetCompaniesWhereDirectorIsFounder(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies where director is founder", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range directorToFounderCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω—ã—Ö —Å–≤—è–∑—è—Ö
			crossPersons, err := r.CompanyService.GetCrossPersonDetails(ctx, obj.Ogrn, company.Ogrn, "director_to_founder")
			if err != nil {
				r.Logger.Warn("failed to get cross person details", 
					zap.String("ogrn1", obj.Ogrn), 
					zap.String("ogrn2", company.Ogrn), 
					zap.Error(err))
				crossPersons = []*model.Person{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}
			
			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
			description := "–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å ‚Üí –£—á—Ä–µ–¥–∏—Ç–µ–ª—å"
			if len(crossPersons) > 0 {
				var names []string
				for _, person := range crossPersons {
					if len(names) >= 3 {
						names = append(names, "...")
						break
					}
					
					var fullName string
					if person.LastName != "" && person.FirstName != "" {
						fullName = person.LastName + " " + person.FirstName
						if person.MiddleName != nil && *person.MiddleName != "" {
							fullName += " " + *person.MiddleName
						}
					}
					
					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if person.Inn != nil && *person.Inn != "" {
						fullName += " (–ò–ù–ù: " + *person.Inn + ")"
					}
					
					if fullName != "" {
						names = append(names, fullName)
					}
				}
				
				if len(names) > 0 {
					description = "–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å ‚Üí –£—á—Ä–µ–¥–∏—Ç–µ–ª—å: " + strings.Join(names, ", ")
				}
			}
			
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeDirectorToFounder,
				Description:      stringPtr(description),
				CommonDirectors:  crossPersons, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–µ CommonDirectors –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
			})
		}
	}

	// 5. –ü–æ–ª—É—á–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏ (–≥–¥–µ –¥–∞–Ω–Ω–∞—è –∫–æ–º–ø–∞–Ω–∏—è —É—á—Ä–µ–¥–∏—Ç–µ–ª—å)
	if obj.Inn != "" {
		subsidiaryCompanies, err := r.CompanyService.GetRelatedCompanies(ctx, obj.Inn, l/6, o)
		if err != nil {
			r.Logger.Error("failed to get subsidiary companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		} else {
			for _, company := range subsidiaryCompanies {
				relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
					Company:          company,
					RelationshipType: model.RelationshipTypeSubsidiaryCompany,
					Description:      stringPtr("–î–æ—á–µ—Ä–Ω—è—è –∫–æ–º–ø–∞–Ω–∏—è"),
				})
			}
		}
	}

	// 6. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º –∞–¥—Ä–µ—Å–æ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
	commonAddressCompanies, err := r.CompanyService.GetCompaniesWithCommonAddress(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common address", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonAddressCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—â–µ–º –∞–¥—Ä–µ—Å–µ
			commonAddress, err := r.CompanyService.GetCommonAddressDetails(ctx, obj.Ogrn, company.Ogrn)
			if err != nil {
				r.Logger.Warn("failed to get common address details", 
					zap.String("ogrn1", obj.Ogrn), 
					zap.String("ogrn2", company.Ogrn), 
					zap.Error(err))
				commonAddress = nil
			}
			
			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –∞–¥—Ä–µ—Å–æ–º
			description := "–û–±—â–∏–π –∞–¥—Ä–µ—Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"
			if commonAddress != nil && commonAddress.FullAddress != nil {
				shortAddress := *commonAddress.FullAddress
				if len(shortAddress) > 100 {
					shortAddress = shortAddress[:97] + "..."
				}
				description = "–û–±—â–∏–π –∞–¥—Ä–µ—Å: " + shortAddress
			}
			
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonAddress,
				Description:      stringPtr(description),
				CommonAddress:    commonAddress,
			})
		}
	}

	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ –∑–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
	if len(relatedCompanies) > l {
		relatedCompanies = relatedCompanies[:l]
	}

	r.Logger.Info("RelatedCompanies loaded", 
		zap.String("ogrn", obj.Ogrn), 
		zap.Int("count", len(relatedCompanies)),
		zap.Int("founder_companies", len(founderCompanies)),
		zap.Int("common_founder_companies", len(commonFounderCompanies)),
	)
	
	return relatedCompanies, nil
}

// stringPtr –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å—Ç—Ä–æ–∫—É
func stringPtr(s string) *string {
	return &s
}

// Company returns CompanyResolver implementation.
func (r *Resolver) Company() CompanyResolver { return &companyResolver{r} }

type companyResolver struct{ *Resolver }

