package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"

	"github.com/egrul-system/services/api-gateway/internal/graph/model"
	"go.uber.org/zap"
)

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context, ogrn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByOGRN(ctx, ogrn)
	if err != nil {
		r.Logger.Error("failed to get company by ogrn", zap.String("ogrn", ogrn), zap.Error(err))
		return nil, err
	}
	return company, nil
}

// CompanyByInn is the resolver for the companyByInn field.
func (r *queryResolver) CompanyByInn(ctx context.Context, inn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get company by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return company, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, filter *model.CompanyFilter, pagination *model.Pagination, sort *model.CompanySort) (*model.CompanyConnection, error) {
	return r.CompanyService.List(ctx, filter, pagination, sort)
}

// SearchCompanies is the resolver for the searchCompanies field.
func (r *queryResolver) SearchCompanies(ctx context.Context, query string, limit *int, offset *int) ([]*model.Company, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.Search(ctx, query, l, o)
}

// Entrepreneur is the resolver for the entrepreneur field.
func (r *queryResolver) Entrepreneur(ctx context.Context, ogrnip string) (*model.Entrepreneur, error) {
	entrepreneur, err := r.EntrepreneurService.GetByOGRNIP(ctx, ogrnip)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by ogrnip", zap.String("ogrnip", ogrnip), zap.Error(err))
		return nil, err
	}
	return entrepreneur, nil
}

// EntrepreneurByInn is the resolver for the entrepreneurByInn field.
func (r *queryResolver) EntrepreneurByInn(ctx context.Context, inn string) (*model.Entrepreneur, error) {
	entrepreneur, err := r.EntrepreneurService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return entrepreneur, nil
}

// Entrepreneurs is the resolver for the entrepreneurs field.
func (r *queryResolver) Entrepreneurs(ctx context.Context, filter *model.EntrepreneurFilter, pagination *model.Pagination, sort *model.EntrepreneurSort) (*model.EntrepreneurConnection, error) {
	return r.EntrepreneurService.List(ctx, filter, pagination, sort)
}

// SearchEntrepreneurs is the resolver for the searchEntrepreneurs field.
func (r *queryResolver) SearchEntrepreneurs(ctx context.Context, query string, limit *int, offset *int) ([]*model.Entrepreneur, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.EntrepreneurService.Search(ctx, query, l, o)
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, limit *int) (*model.SearchResult, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	return r.SearchService.Search(ctx, query, l)
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context, filter *model.StatsFilter) (*model.Statistics, error) {
	return r.StatisticsService.GetStatistics(ctx, filter)
}

// EntityHistory is the resolver for the entityHistory field.
func (r *queryResolver) EntityHistory(ctx context.Context, entityType model.EntityType, entityID string, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	r.Logger.Info("EntityHistory resolver called - DIRECT QUERY", 
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Any("limit", limit),
		zap.Any("offset", offset),
	)
	
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	
	r.Logger.Info("EntityHistory parameters", 
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Int("resolved_limit", l),
		zap.Int("resolved_offset", o),
	)
	
	// Используем CompanyService для компаний и EntrepreneurService для ИП
	if entityType == model.EntityTypeCompany {
		history, err := r.CompanyService.GetHistory(ctx, entityID, l, o)
		if err != nil {
			r.Logger.Error("failed to get company history", zap.String("entityID", entityID), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("EntityHistory loaded for company", 
			zap.String("entityID", entityID),
			zap.Int("count", len(history)),
			zap.String("first_grn", func() string {
				if len(history) > 0 { return history[0].Grn }
				return "none"
			}()),
			zap.String("last_grn", func() string {
				if len(history) > 0 { return history[len(history)-1].Grn }
				return "none"
			}()),
		)
		return history, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistory(ctx, entityID, l, o)
	}
	return nil, fmt.Errorf("unsupported entity type: %v", entityType)
}

// EntityHistoryCount is the resolver for the entityHistoryCount field.
func (r *queryResolver) EntityHistoryCount(ctx context.Context, entityType model.EntityType, entityID string) (int, error) {
	r.Logger.Info("EntityHistoryCount resolver called - DIRECT QUERY", 
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
	)
	
	// Используем CompanyService для компаний и EntrepreneurService для ИП
	if entityType == model.EntityTypeCompany {
		count, err := r.CompanyService.GetHistoryCount(ctx, entityID)
		if err != nil {
			r.Logger.Error("failed to get company history count", zap.String("entityID", entityID), zap.Error(err))
			return 0, err
		}
		r.Logger.Info("EntityHistoryCount loaded for company", 
			zap.String("entityID", entityID),
			zap.Int("count", count),
		)
		return count, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistoryCount(ctx, entityID)
	}
	return 0, fmt.Errorf("unsupported entity type: %v", entityType)
}

// CompanyFounders is the resolver for the companyFounders field.
func (r *queryResolver) CompanyFounders(ctx context.Context, ogrn string, limit *int, offset *int) ([]*model.Founder, error) {
	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetFounders(ctx, ogrn, l, o)
}

// RelatedCompanies is the resolver for the relatedCompanies field.
func (r *queryResolver) RelatedCompanies(ctx context.Context, inn string, limit *int, offset *int) ([]*model.Company, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetRelatedCompanies(ctx, inn, l, o)
}

