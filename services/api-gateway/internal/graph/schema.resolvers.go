package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"time"

	"github.com/egrul-system/services/api-gateway/internal/cache"
	"github.com/egrul-system/services/api-gateway/internal/graph/model"
	"go.uber.org/zap"
)

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context, ogrn string) (*model.Company, error) {
	cacheKey := fmt.Sprintf("company:ogrn:%s", ogrn)

	// Попытка прочитать из кэша
	if r.Cache != nil {
		var cached model.Company
		found, err := r.Cache.Get(ctx, cacheKey, &cached)
		if err != nil {
			r.Logger.Warn("failed to get company from cache", zap.String("ogrn", ogrn), zap.Error(err))
		} else if found {
			return &cached, nil
		}
	}

	company, err := r.CompanyService.GetByOGRN(ctx, ogrn)
	if err != nil {
		r.Logger.Error("failed to get company by ogrn", zap.String("ogrn", ogrn), zap.Error(err))
		return nil, err
	}
	if company == nil {
		return nil, nil
	}

	// Сохраняем в кэш
	if r.Cache != nil {
		if err := r.Cache.Set(ctx, cacheKey, company, cache.DefaultTTL); err != nil {
			r.Logger.Warn("failed to set company to cache", zap.String("ogrn", ogrn), zap.Error(err))
		}
	}
	return company, nil
}

// CompanyByInn is the resolver for the companyByInn field.
func (r *queryResolver) CompanyByInn(ctx context.Context, inn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get company by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return company, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, filter *model.CompanyFilter, pagination *model.Pagination, sort *model.CompanySort) (*model.CompanyConnection, error) {
	if pagination == nil {
		pagination = &model.Pagination{}
	}
	
	connection, err := r.CompanyService.List(ctx, filter, pagination, sort)
	if err != nil {
		r.Logger.Error("failed to list companies", zap.Error(err))
		return nil, err
	}
	return connection, nil
}

// SearchCompanies is the resolver for the searchCompanies field.
func (r *queryResolver) SearchCompanies(ctx context.Context, query string, limit *int, offset *int) ([]*model.Company, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	companies, err := r.CompanyService.Search(ctx, query, l, o)
	if err != nil {
		r.Logger.Error("failed to search companies", zap.String("query", query), zap.Error(err))
		return nil, err
	}
	return companies, nil
}

// Entrepreneur is the resolver for the entrepreneur field.
func (r *queryResolver) Entrepreneur(ctx context.Context, ogrnip string) (*model.Entrepreneur, error) {
	cacheKey := fmt.Sprintf("entrepreneur:ogrnip:%s", ogrnip)

	// Попытка прочитать из кэша
	if r.Cache != nil {
		var cached model.Entrepreneur
		found, err := r.Cache.Get(ctx, cacheKey, &cached)
		if err != nil {
			r.Logger.Warn("failed to get entrepreneur from cache", zap.String("ogrnip", ogrnip), zap.Error(err))
		} else if found {
			return &cached, nil
		}
	}

	entrepreneur, err := r.EntrepreneurService.GetByOGRNIP(ctx, ogrnip)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by ogrnip", zap.String("ogrnip", ogrnip), zap.Error(err))
		return nil, err
	}
	if entrepreneur == nil {
		return nil, nil
	}

	// Сохраняем в кэш
	if r.Cache != nil {
		if err := r.Cache.Set(ctx, cacheKey, entrepreneur, cache.DefaultTTL); err != nil {
			r.Logger.Warn("failed to set entrepreneur to cache", zap.String("ogrnip", ogrnip), zap.Error(err))
		}
	}
	return entrepreneur, nil
}

// EntrepreneurByInn is the resolver for the entrepreneurByInn field.
func (r *queryResolver) EntrepreneurByInn(ctx context.Context, inn string) (*model.Entrepreneur, error) {
	entrepreneur, err := r.EntrepreneurService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return entrepreneur, nil
}

// Entrepreneurs is the resolver for the entrepreneurs field.
func (r *queryResolver) Entrepreneurs(ctx context.Context, filter *model.EntrepreneurFilter, pagination *model.Pagination) (*model.EntrepreneurConnection, error) {
	if pagination == nil {
		pagination = &model.Pagination{}
	}

	connection, err := r.EntrepreneurService.List(ctx, filter, pagination)
	if err != nil {
		r.Logger.Error("failed to list entrepreneurs", zap.Error(err))
		return nil, err
	}
	return connection, nil
}

// SearchEntrepreneurs is the resolver for the searchEntrepreneurs field.
func (r *queryResolver) SearchEntrepreneurs(ctx context.Context, query string, limit *int, offset *int) ([]*model.Entrepreneur, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	entrepreneurs, err := r.EntrepreneurService.Search(ctx, query, l, o)
	if err != nil {
		r.Logger.Error("failed to search entrepreneurs", zap.String("query", query), zap.Error(err))
		return nil, err
	}
	return entrepreneurs, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, limit *int) (*model.SearchResult, error) {
	l := 10
	if limit != nil {
		l = *limit
	}

	result, err := r.SearchService.Search(ctx, query, l)
	if err != nil {
		r.Logger.Error("failed to search", zap.String("query", query), zap.Error(err))
		return nil, err
	}
	return result, nil
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context, filter *model.StatsFilter) (*model.Statistics, error) {
	// Формируем ключ кэша на основе фильтра
	cacheKey := "statistics:global"
	if filter != nil {
		// Упрощённый ключ по основным полям фильтра и округлению дат до дня
		region := ""
		okved := ""
		var from, to string
		if filter.RegionCode != nil {
			region = *filter.RegionCode
		}
		if filter.Okved != nil {
			okved = *filter.Okved
		}
		if filter.DateFrom != nil {
			from = filter.DateFrom.Time.Truncate(24 * time.Hour).Format("2006-01-02")
		}
		if filter.DateTo != nil {
			to = filter.DateTo.Time.Truncate(24 * time.Hour).Format("2006-01-02")
		}
		cacheKey = fmt.Sprintf("statistics:r=%s:o=%s:f=%s:t=%s", region, okved, from, to)
	}

	if r.Cache != nil {
		var cached model.Statistics
		found, err := r.Cache.Get(ctx, cacheKey, &cached)
		if err != nil {
			r.Logger.Warn("failed to get statistics from cache", zap.String("key", cacheKey), zap.Error(err))
		} else if found {
			return &cached, nil
		}
	}

	stats, err := r.StatisticsService.GetStatistics(ctx, filter)
	if err != nil {
		r.Logger.Error("failed to get statistics", zap.Error(err))
		return nil, err
	}

	if r.Cache != nil {
		// Для статистики можно использовать чуть меньший TTL, если нужно более свежее значение
		ttl := cache.DefaultTTL
		if err := r.Cache.Set(ctx, cacheKey, stats, ttl); err != nil {
			r.Logger.Warn("failed to set statistics to cache", zap.String("key", cacheKey), zap.Error(err))
		}
	}
	return stats, nil
}

// EntityHistory is the resolver for the entityHistory field.
func (r *queryResolver) EntityHistory(ctx context.Context, entityType model.EntityType, entityID string, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	if entityType == model.EntityTypeCompany {
		return r.CompanyService.GetHistory(ctx, entityID, l, o)
	}
	return r.EntrepreneurService.GetHistory(ctx, entityID, l, o)
}

// CompanyFounders is the resolver for the companyFounders field.
func (r *queryResolver) CompanyFounders(ctx context.Context, ogrn string, limit *int, offset *int) ([]*model.Founder, error) {
	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	founders, err := r.CompanyService.GetFounders(ctx, ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get company founders", zap.String("ogrn", ogrn), zap.Error(err))
		return nil, err
	}
	return founders, nil
}

// RelatedCompanies is the resolver for the relatedCompanies field.
func (r *queryResolver) RelatedCompanies(ctx context.Context, inn string, limit *int, offset *int) ([]*model.Company, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	companies, err := r.CompanyService.GetRelatedCompanies(ctx, inn, l, o)
	if err != nil {
		r.Logger.Error("failed to get related companies", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return companies, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

