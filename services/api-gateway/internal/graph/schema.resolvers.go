package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/egrul-system/services/api-gateway/internal/graph/generated"
	"github.com/egrul-system/services/api-gateway/internal/graph/model"
)

// Founders is the resolver for the founders field on Company.
func (r *companyResolver) Founders(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.Founder, error) {
	r.Logger.Info("Founders resolver called", zap.String("ogrn", obj.Ogrn))

	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	// –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å DataLoader (per-request cache)
	if loader := foundersLoaderFromContext(ctx); loader != nil {
		founders, err := loader.Load(ctx, obj.Ogrn, l, o)
		if err != nil {
			r.Logger.Error("failed to get founders via dataloader", zap.String("ogrn", obj.Ogrn), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("Founders loaded via dataloader", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
		return founders, nil
	}

	// Fallback –∫ –ø—Ä—è–º–æ–º—É –≤—ã–∑–æ–≤—É —Å–µ—Ä–≤–∏—Å–∞
	founders, err := r.CompanyService.GetFounders(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	r.Logger.Info("Founders loaded directly", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
	return founders, nil
}

// Licenses is the resolver for the licenses field on Company.
func (r *companyResolver) Licenses(ctx context.Context, obj *model.Company) ([]*model.License, error) {
	licenses, err := r.CompanyService.GetLicenses(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get licenses", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return licenses, nil
}

// Branches is the resolver for the branches field on Company.
func (r *companyResolver) Branches(ctx context.Context, obj *model.Company) ([]*model.Branch, error) {
	branches, err := r.CompanyService.GetBranches(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get branches", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return branches, nil
}

// History is the resolver for the history field on Company.
func (r *companyResolver) History(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	// –ü–æ–ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ GraphQL –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
	fc := graphql.GetFieldContext(ctx)
	var l, o int = 50, 0

	r.Logger.Error("üî• CRITICAL DEBUG - History resolver called",
		zap.String("ogrn", obj.Ogrn),
		zap.Any("limit_ptr", limit),
		zap.Any("offset_ptr", offset),
		zap.Bool("limit_is_nil", limit == nil),
		zap.Bool("offset_is_nil", offset == nil),
		zap.Any("field_context", fc),
	)

	// –ü—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ GraphQL
	if fc != nil && fc.Args != nil {
		r.Logger.Info("üîç Checking GraphQL field context args", zap.Any("args", fc.Args))

		if limitArg, ok := fc.Args["limit"]; ok && limitArg != nil {
			if limitPtr, ok := limitArg.(*int); ok && limitPtr != nil {
				l = *limitPtr
				r.Logger.Info("‚úÖ Extracted limit from GraphQL context", zap.Int("limit", l))
			}
		}

		if offsetArg, ok := fc.Args["offset"]; ok && offsetArg != nil {
			if offsetPtr, ok := offsetArg.(*int); ok && offsetPtr != nil {
				o = *offsetPtr
				r.Logger.Info("‚úÖ Extracted offset from GraphQL context", zap.Int("offset", o))
			}
		}
	}

	// Fallback –∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º —Ñ—É–Ω–∫—Ü–∏–∏
	if limit != nil {
		l = *limit
		r.Logger.Info("‚úÖ Using limit from function parameter", zap.Int("limit", l))
	}

	if offset != nil {
		o = *offset
		r.Logger.Info("‚úÖ Using offset from function parameter", zap.Int("offset", o))
	}

	r.Logger.Info("üîç Final parameters for CompanyService.GetHistory",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("final_limit", l),
		zap.Int("final_offset", o))

	history, err := r.CompanyService.GetHistory(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get history", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}

	r.Logger.Info("üìä History loaded successfully",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("requested_limit", l),
		zap.Int("requested_offset", o),
		zap.Int("returned_count", len(history)),
		zap.String("first_grn", func() string {
			if len(history) > 0 {
				return history[0].Grn
			}
			return "none"
		}()),
		zap.String("last_grn", func() string {
			if len(history) > 0 {
				return history[len(history)-1].Grn
			}
			return "none"
		}()),
	)
	return history, nil
}

// HistoryCount is the resolver for the historyCount field on Company.
func (r *companyResolver) HistoryCount(ctx context.Context, obj *model.Company) (int, error) {
	r.Logger.Info("HistoryCount resolver called", zap.String("ogrn", obj.Ogrn))

	count, err := r.CompanyService.GetHistoryCount(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get history count", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return 0, err
	}
	r.Logger.Info("HistoryCount loaded", zap.String("ogrn", obj.Ogrn), zap.Int("count", count))
	return count, nil
}

// RelatedCompanies is the resolver for the relatedCompanies field on Company.
func (r *companyResolver) RelatedCompanies(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.RelatedCompany, error) {
	r.Logger.Info("RelatedCompanies resolver called", zap.String("ogrn", obj.Ogrn))

	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	var relatedCompanies []*model.RelatedCompany

	// 1. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏-—É—á—Ä–µ–¥–∏—Ç–µ–ª–∏ (—é—Ä–∏–¥–∏—á–µ—Å–∫–∏–µ –ª–∏—Ü–∞ –≤ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è—Ö)
	founderCompanies, err := r.CompanyService.GetFounderCompanies(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get founder companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range founderCompanies {
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeFounderCompany,
				Description:      stringPtr("–ö–æ–º–ø–∞–Ω–∏—è-—É—á—Ä–µ–¥–∏—Ç–µ–ª—å"),
			})
		}
	}

	// 2. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º–∏ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è–º–∏-—Ñ–∏–∑–ª–∏—Ü–∞–º–∏
	commonFounderCompanies, err := r.CompanyService.GetCompaniesWithCommonFounders(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonFounderCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—â–∏—Ö —É—á—Ä–µ–¥–∏—Ç–µ–ª—è—Ö
			commonFounders, err := r.CompanyService.GetCommonFoundersDetails(ctx, obj.Ogrn, company.Ogrn)
			if err != nil {
				r.Logger.Warn("failed to get common founders details",
					zap.String("ogrn1", obj.Ogrn),
					zap.String("ogrn2", company.Ogrn),
					zap.Error(err))
				commonFounders = []*model.Founder{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}

			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –∏–º–µ–Ω–∞–º–∏ –æ–±—â–∏—Ö —É—á—Ä–µ–¥–∏—Ç–µ–ª–µ–π
			description := "–û–±—â–∏–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏-—Ñ–∏–∑–ª–∏—Ü–∞"
			if len(commonFounders) > 0 {
				var names []string
				for _, founder := range commonFounders {
					if len(names) >= 3 { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 3 –∏–º–µ–Ω –≤ –æ–ø–∏—Å–∞–Ω–∏–∏
						names = append(names, "...")
						break
					}

					// –§–æ—Ä–º–∏—Ä—É–µ–º –§–ò–û —Å –ò–ù–ù
					var fullName string
					if founder.LastName != nil && founder.FirstName != nil {
						fullName = *founder.LastName + " " + *founder.FirstName
						if founder.MiddleName != nil && *founder.MiddleName != "" {
							fullName += " " + *founder.MiddleName
						}
					} else {
						fullName = founder.Name
					}

					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if founder.Inn != nil && *founder.Inn != "" {
						fullName += " (–ò–ù–ù: " + *founder.Inn + ")"
					}

					names = append(names, fullName)
				}

				if len(names) > 0 {
					description = "–û–±—â–∏–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏: " + strings.Join(names, ", ")
				}
			}

			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonFounders,
				Description:      stringPtr(description),
				CommonFounders:   commonFounders,
			})
		}
	}

	// 2.5. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º–∏ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º–∏-—Ñ–∏–∑–ª–∏—Ü–∞–º–∏
	commonDirectorCompanies, err := r.CompanyService.GetCompaniesWithCommonDirectors(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common directors", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonDirectorCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—â–∏—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è—Ö
			commonDirectors, err := r.CompanyService.GetCommonDirectorsDetails(ctx, obj.Ogrn, company.Ogrn)
			if err != nil {
				r.Logger.Warn("failed to get common directors details",
					zap.String("ogrn1", obj.Ogrn),
					zap.String("ogrn2", company.Ogrn),
					zap.Error(err))
				commonDirectors = []*model.Person{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}

			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –∏–º–µ–Ω–∞–º–∏ –æ–±—â–∏—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π
			description := "–û–±—â–∏–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏-—Ñ–∏–∑–ª–∏—Ü–∞"
			if len(commonDirectors) > 0 {
				var names []string
				for _, director := range commonDirectors {
					if len(names) >= 3 { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 3 –∏–º–µ–Ω –≤ –æ–ø–∏—Å–∞–Ω–∏–∏
						names = append(names, "...")
						break
					}

					// –§–æ—Ä–º–∏—Ä—É–µ–º –§–ò–û —Å –ò–ù–ù
					var fullName string
					if director.LastName != "" && director.FirstName != "" {
						fullName = director.LastName + " " + director.FirstName
						if director.MiddleName != nil && *director.MiddleName != "" {
							fullName += " " + *director.MiddleName
						}
					}

					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if director.Inn != nil && *director.Inn != "" {
						fullName += " (–ò–ù–ù: " + *director.Inn + ")"
					}

					if fullName != "" {
						names = append(names, fullName)
					}
				}

				if len(names) > 0 {
					description = "–û–±—â–∏–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏: " + strings.Join(names, ", ")
				}
			}

			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonDirectors,
				Description:      stringPtr(description),
				CommonDirectors:  commonDirectors,
			})
		}
	}

	// 3. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏, –≥–¥–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ —è–≤–ª—è—é—Ç—Å—è —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º–∏
	founderToDirectorCompanies, err := r.CompanyService.GetCompaniesWhereFounderIsDirector(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies where founder is director", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range founderToDirectorCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω—ã—Ö —Å–≤—è–∑—è—Ö
			crossPersons, err := r.CompanyService.GetCrossPersonDetails(ctx, obj.Ogrn, company.Ogrn, "founder_to_director")
			if err != nil {
				r.Logger.Warn("failed to get cross person details",
					zap.String("ogrn1", obj.Ogrn),
					zap.String("ogrn2", company.Ogrn),
					zap.Error(err))
				crossPersons = []*model.Person{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}

			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
			description := "–£—á—Ä–µ–¥–∏—Ç–µ–ª—å ‚Üí –†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å"
			if len(crossPersons) > 0 {
				var names []string
				for _, person := range crossPersons {
					if len(names) >= 3 {
						names = append(names, "...")
						break
					}

					var fullName string
					if person.LastName != "" && person.FirstName != "" {
						fullName = person.LastName + " " + person.FirstName
						if person.MiddleName != nil && *person.MiddleName != "" {
							fullName += " " + *person.MiddleName
						}
					}

					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if person.Inn != nil && *person.Inn != "" {
						fullName += " (–ò–ù–ù: " + *person.Inn + ")"
					}

					if fullName != "" {
						names = append(names, fullName)
					}
				}

				if len(names) > 0 {
					description = "–£—á—Ä–µ–¥–∏—Ç–µ–ª—å ‚Üí –†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å: " + strings.Join(names, ", ")
				}
			}

			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeFounderToDirector,
				Description:      stringPtr(description),
				CommonDirectors:  crossPersons, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–µ CommonDirectors –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
			})
		}
	}

	// 4. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏, –≥–¥–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ —è–≤–ª—è–µ—Ç—Å—è —É—á—Ä–µ–¥–∏—Ç–µ–ª–µ–º
	directorToFounderCompanies, err := r.CompanyService.GetCompaniesWhereDirectorIsFounder(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies where director is founder", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range directorToFounderCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω—ã—Ö —Å–≤—è–∑—è—Ö
			crossPersons, err := r.CompanyService.GetCrossPersonDetails(ctx, obj.Ogrn, company.Ogrn, "director_to_founder")
			if err != nil {
				r.Logger.Warn("failed to get cross person details",
					zap.String("ogrn1", obj.Ogrn),
					zap.String("ogrn2", company.Ogrn),
					zap.Error(err))
				crossPersons = []*model.Person{} // –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
			}

			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
			description := "–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å ‚Üí –£—á—Ä–µ–¥–∏—Ç–µ–ª—å"
			if len(crossPersons) > 0 {
				var names []string
				for _, person := range crossPersons {
					if len(names) >= 3 {
						names = append(names, "...")
						break
					}

					var fullName string
					if person.LastName != "" && person.FirstName != "" {
						fullName = person.LastName + " " + person.FirstName
						if person.MiddleName != nil && *person.MiddleName != "" {
							fullName += " " + *person.MiddleName
						}
					}

					// –î–æ–±–∞–≤–ª—è–µ–º –ò–ù–ù –≤ —Å–∫–æ–±–∫–∞—Ö
					if person.Inn != nil && *person.Inn != "" {
						fullName += " (–ò–ù–ù: " + *person.Inn + ")"
					}

					if fullName != "" {
						names = append(names, fullName)
					}
				}

				if len(names) > 0 {
					description = "–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å ‚Üí –£—á—Ä–µ–¥–∏—Ç–µ–ª—å: " + strings.Join(names, ", ")
				}
			}

			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeDirectorToFounder,
				Description:      stringPtr(description),
				CommonDirectors:  crossPersons, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–µ CommonDirectors –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
			})
		}
	}

	// 5. –ü–æ–ª—É—á–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏ (–≥–¥–µ –¥–∞–Ω–Ω–∞—è –∫–æ–º–ø–∞–Ω–∏—è —É—á—Ä–µ–¥–∏—Ç–µ–ª—å)
	if obj.Inn != "" {
		subsidiaryCompanies, err := r.CompanyService.GetRelatedCompanies(ctx, obj.Inn, l/6, o)
		if err != nil {
			r.Logger.Error("failed to get subsidiary companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		} else {
			for _, company := range subsidiaryCompanies {
				relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
					Company:          company,
					RelationshipType: model.RelationshipTypeSubsidiaryCompany,
					Description:      stringPtr("–î–æ—á–µ—Ä–Ω—è—è –∫–æ–º–ø–∞–Ω–∏—è"),
				})
			}
		}
	}

	// 6. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º –∞–¥—Ä–µ—Å–æ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
	commonAddressCompanies, err := r.CompanyService.GetCompaniesWithCommonAddress(ctx, obj.Ogrn, l/6, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common address", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonAddressCompanies {
			// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—â–µ–º –∞–¥—Ä–µ—Å–µ
			commonAddress, err := r.CompanyService.GetCommonAddressDetails(ctx, obj.Ogrn, company.Ogrn)
			if err != nil {
				r.Logger.Warn("failed to get common address details",
					zap.String("ogrn1", obj.Ogrn),
					zap.String("ogrn2", company.Ogrn),
					zap.Error(err))
				commonAddress = nil
			}

			// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –∞–¥—Ä–µ—Å–æ–º
			description := "–û–±—â–∏–π –∞–¥—Ä–µ—Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"
			if commonAddress != nil && commonAddress.FullAddress != nil {
				shortAddress := *commonAddress.FullAddress
				if len(shortAddress) > 100 {
					shortAddress = shortAddress[:97] + "..."
				}
				description = "–û–±—â–∏–π –∞–¥—Ä–µ—Å: " + shortAddress
			}

			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonAddress,
				Description:      stringPtr(description),
				CommonAddress:    commonAddress,
			})
		}
	}

	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ –∑–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
	if len(relatedCompanies) > l {
		relatedCompanies = relatedCompanies[:l]
	}

	r.Logger.Info("RelatedCompanies loaded",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("count", len(relatedCompanies)),
		zap.Int("founder_companies", len(founderCompanies)),
		zap.Int("common_founder_companies", len(commonFounderCompanies)),
	)

	return relatedCompanies, nil
}

// Licenses is the resolver for the licenses field on Entrepreneur.
func (r *entrepreneurResolver) Licenses(ctx context.Context, obj *model.Entrepreneur) ([]*model.License, error) {
	licenses, err := r.EntrepreneurService.GetLicenses(ctx, obj.Ogrnip)
	if err != nil {
		r.Logger.Error("failed to get licenses", zap.String("ogrnip", obj.Ogrnip), zap.Error(err))
		return nil, err
	}
	return licenses, nil
}

// History is the resolver for the history field on Entrepreneur.
func (r *entrepreneurResolver) History(ctx context.Context, obj *model.Entrepreneur, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	r.Logger.Info("üî• SCHEMA.RESOLVERS - History resolver called", zap.String("ogrnip", obj.Ogrnip))

	history, err := r.EntrepreneurService.GetHistory(ctx, obj.Ogrnip, l, o)
	if err != nil {
		r.Logger.Error("failed to get history", zap.String("ogrnip", obj.Ogrnip), zap.Error(err))
		return nil, err
	}
	
	r.Logger.Info("üî• SCHEMA.RESOLVERS - History loaded", zap.String("ogrnip", obj.Ogrnip), zap.Int("count", len(history)))
	return history, nil
}

// HistoryCount is the resolver for the historyCount field on Entrepreneur.
func (r *entrepreneurResolver) HistoryCount(ctx context.Context, obj *model.Entrepreneur) (int, error) {
	r.Logger.Info("üî• SCHEMA.RESOLVERS - HistoryCount resolver called", zap.String("ogrnip", obj.Ogrnip))

	count, err := r.EntrepreneurService.GetHistoryCount(ctx, obj.Ogrnip)
	if err != nil {
		r.Logger.Error("failed to get history count", zap.String("ogrnip", obj.Ogrnip), zap.Error(err))
		return 0, err
	}
	r.Logger.Info("üî• SCHEMA.RESOLVERS - HistoryCount loaded", zap.String("ogrnip", obj.Ogrnip), zap.Int("count", count))
	return count, nil
}

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context, ogrn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByOGRN(ctx, ogrn)
	if err != nil {
		r.Logger.Error("failed to get company by ogrn", zap.String("ogrn", ogrn), zap.Error(err))
		return nil, err
	}
	return company, nil
}

// CompanyByInn is the resolver for the companyByInn field.
func (r *queryResolver) CompanyByInn(ctx context.Context, inn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get company by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return company, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, filter *model.CompanyFilter, pagination *model.Pagination, sort *model.CompanySort) (*model.CompanyConnection, error) {
	return r.CompanyService.List(ctx, filter, pagination, sort)
}

// SearchCompanies is the resolver for the searchCompanies field.
func (r *queryResolver) SearchCompanies(ctx context.Context, query string, limit *int, offset *int) ([]*model.Company, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.Search(ctx, query, l, o)
}

// Entrepreneur is the resolver for the entrepreneur field.
func (r *queryResolver) Entrepreneur(ctx context.Context, ogrnip string) (*model.Entrepreneur, error) {
	r.Logger.Info("üîç Entrepreneur query resolver called", zap.String("ogrnip", ogrnip))

	entrepreneur, err := r.EntrepreneurService.GetByOGRNIP(ctx, ogrnip)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by ogrnip", zap.String("ogrnip", ogrnip), zap.Error(err))
		return nil, err
	}

	r.Logger.Info("‚úÖ Entrepreneur loaded successfully",
		zap.String("ogrnip", ogrnip),
		zap.String("name", entrepreneur.FirstName+" "+entrepreneur.LastName))

	return entrepreneur, nil
}

// EntrepreneurByInn is the resolver for the entrepreneurByInn field.
func (r *queryResolver) EntrepreneurByInn(ctx context.Context, inn string) (*model.Entrepreneur, error) {
	entrepreneur, err := r.EntrepreneurService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return entrepreneur, nil
}

// Entrepreneurs is the resolver for the entrepreneurs field.
func (r *queryResolver) Entrepreneurs(ctx context.Context, filter *model.EntrepreneurFilter, pagination *model.Pagination, sort *model.EntrepreneurSort) (*model.EntrepreneurConnection, error) {
	return r.EntrepreneurService.List(ctx, filter, pagination, sort)
}

// SearchEntrepreneurs is the resolver for the searchEntrepreneurs field.
func (r *queryResolver) SearchEntrepreneurs(ctx context.Context, query string, limit *int, offset *int) ([]*model.Entrepreneur, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.EntrepreneurService.Search(ctx, query, l, o)
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, limit *int) (*model.SearchResult, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	return r.SearchService.Search(ctx, query, l)
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context, filter *model.StatsFilter) (*model.Statistics, error) {
	return r.StatisticsService.GetStatistics(ctx, filter)
}

// EntityHistory is the resolver for the entityHistory field.
func (r *queryResolver) EntityHistory(ctx context.Context, entityType model.EntityType, entityID string, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	r.Logger.Info("EntityHistory resolver called - DIRECT QUERY",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Any("limit", limit),
		zap.Any("offset", offset),
	)

	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	r.Logger.Info("EntityHistory parameters",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Int("resolved_limit", l),
		zap.Int("resolved_offset", o),
	)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º CompanyService –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–π –∏ EntrepreneurService –¥–ª—è –ò–ü
	if entityType == model.EntityTypeCompany {
		history, err := r.CompanyService.GetHistory(ctx, entityID, l, o)
		if err != nil {
			r.Logger.Error("failed to get company history", zap.String("entityID", entityID), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("EntityHistory loaded for company",
			zap.String("entityID", entityID),
			zap.Int("count", len(history)),
			zap.String("first_grn", func() string {
				if len(history) > 0 {
					return history[0].Grn
				}
				return "none"
			}()),
			zap.String("last_grn", func() string {
				if len(history) > 0 {
					return history[len(history)-1].Grn
				}
				return "none"
			}()),
		)
		return history, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistory(ctx, entityID, l, o)
	}
	return nil, fmt.Errorf("unsupported entity type: %v", entityType)
}

// EntityHistoryCount is the resolver for the entityHistoryCount field.
func (r *queryResolver) EntityHistoryCount(ctx context.Context, entityType model.EntityType, entityID string) (int, error) {
	r.Logger.Info("EntityHistoryCount resolver called - DIRECT QUERY",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
	)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º CompanyService –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–π –∏ EntrepreneurService –¥–ª—è –ò–ü
	if entityType == model.EntityTypeCompany {
		count, err := r.CompanyService.GetHistoryCount(ctx, entityID)
		if err != nil {
			r.Logger.Error("failed to get company history count", zap.String("entityID", entityID), zap.Error(err))
			return 0, err
		}
		r.Logger.Info("EntityHistoryCount loaded for company",
			zap.String("entityID", entityID),
			zap.Int("count", count),
		)
		return count, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistoryCount(ctx, entityID)
	}
	return 0, fmt.Errorf("unsupported entity type: %v", entityType)
}

// CompanyFounders is the resolver for the companyFounders field.
func (r *queryResolver) CompanyFounders(ctx context.Context, ogrn string, limit *int, offset *int) ([]*model.Founder, error) {
	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetFounders(ctx, ogrn, l, o)
}

// RelatedCompanies is the resolver for the relatedCompanies field.
func (r *queryResolver) RelatedCompanies(ctx context.Context, inn string, limit *int, offset *int) ([]*model.Company, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetRelatedCompanies(ctx, inn, l, o)
}

// Company returns generated.CompanyResolver implementation.
func (r *Resolver) Company() generated.CompanyResolver { return &companyResolver{r} }

// Entrepreneur returns generated.EntrepreneurResolver implementation.
func (r *Resolver) Entrepreneur() generated.EntrepreneurResolver { return &entrepreneurResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type companyResolver struct{ *Resolver }
type entrepreneurResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *companyResolver) Founders(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.Founder, error) {
	r.Logger.Info("Founders resolver called", zap.String("ogrn", obj.Ogrn))

	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	// –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å DataLoader (per-request cache)
	if loader := foundersLoaderFromContext(ctx); loader != nil {
		founders, err := loader.Load(ctx, obj.Ogrn, l, o)
		if err != nil {
			r.Logger.Error("failed to get founders via dataloader", zap.String("ogrn", obj.Ogrn), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("Founders loaded via dataloader", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
		return founders, nil
	}

	// Fallback –∫ –ø—Ä—è–º–æ–º—É –≤—ã–∑–æ–≤—É —Å–µ—Ä–≤–∏—Å–∞
	founders, err := r.CompanyService.GetFounders(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	r.Logger.Info("Founders loaded directly", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
	return founders, nil
}
func (r *companyResolver) Licenses(ctx context.Context, obj *model.Company) ([]*model.License, error) {
	licenses, err := r.CompanyService.GetLicenses(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get licenses", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return licenses, nil
}
func (r *companyResolver) Branches(ctx context.Context, obj *model.Company) ([]*model.Branch, error) {
	branches, err := r.CompanyService.GetBranches(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get branches", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return branches, nil
}
func (r *companyResolver) History(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	// –ü–æ–ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ GraphQL –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
	fc := graphql.GetFieldContext(ctx)
	var l, o int = 50, 0

	r.Logger.Error("üî• CRITICAL DEBUG - History resolver called",
		zap.String("ogrn", obj.Ogrn),
		zap.Any("limit_ptr", limit),
		zap.Any("offset_ptr", offset),
		zap.Bool("limit_is_nil", limit == nil),
		zap.Bool("offset_is_nil", offset == nil),
		zap.Any("field_context", fc),
	)

	// –ü—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ GraphQL
	if fc != nil && fc.Args != nil {
		r.Logger.Info("üîç Checking GraphQL field context args", zap.Any("args", fc.Args))

		if limitArg, ok := fc.Args["limit"]; ok && limitArg != nil {
			if limitPtr, ok := limitArg.(*int); ok && limitPtr != nil {
				l = *limitPtr
				r.Logger.Info("‚úÖ Extracted limit from GraphQL context", zap.Int("limit", l))
			}
		}

		if offsetArg, ok := fc.Args["offset"]; ok && offsetArg != nil {
			if offsetPtr, ok := offsetArg.(*int); ok && offsetPtr != nil {
				o = *offsetPtr
				r.Logger.Info("‚úÖ Extracted offset from GraphQL context", zap.Int("offset", o))
			}
		}
	}

	// Fallback –∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º —Ñ—É–Ω–∫—Ü–∏–∏
	if limit != nil {
		l = *limit
		r.Logger.Info("‚úÖ Using limit from function parameter", zap.Int("limit", l))
	}

	if offset != nil {
		o = *offset
		r.Logger.Info("‚úÖ Using offset from function parameter", zap.Int("offset", o))
	}

	r.Logger.Info("üîç Final parameters for CompanyService.GetHistory",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("final_limit", l),
		zap.Int("final_offset", o))

	history, err := r.CompanyService.GetHistory(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get history", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}

	r.Logger.Info("üìä History loaded successfully",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("requested_limit", l),
		zap.Int("requested_offset", o),
		zap.Int("returned_count", len(history)),
		zap.String("first_grn", func() string {
			if len(history) > 0 {
				return history[0].Grn
			}
			return "none"
		}()),
		zap.String("last_grn", func() string {
			if len(history) > 0 {
				return history[len(history)-1].Grn
			}
			return "none"
		}()),
	)
	return history, nil
}
func (r *companyResolver) HistoryCount(ctx context.Context, obj *model.Company) (int, error) {
	r.Logger.Info("HistoryCount resolver called", zap.String("ogrn", obj.Ogrn))

	count, err := r.CompanyService.GetHistoryCount(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get history count", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return 0, err
	}
	r.Logger.Info("HistoryCount loaded", zap.String("ogrn", obj.Ogrn), zap.Int("count", count))
	return count, nil
}
func (r *companyResolver) RelatedCompanies(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.RelatedCompany, error) {
	r.Logger.Info("RelatedCompanies resolver called", zap.String("ogrn", obj.Ogrn))

	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	var relatedCompanies []*model.RelatedCompany

	// 1. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏-—É—á—Ä–µ–¥–∏—Ç–µ–ª–∏ (—é—Ä–∏–¥–∏—á–µ—Å–∫–∏–µ –ª–∏—Ü–∞ –≤ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è—Ö)
	founderCompanies, err := r.CompanyService.GetFounderCompanies(ctx, obj.Ogrn, l/3, o)
	if err != nil {
		r.Logger.Error("failed to get founder companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range founderCompanies {
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeFounderCompany,
				Description:      stringPtr("–ö–æ–º–ø–∞–Ω–∏—è-—É—á—Ä–µ–¥–∏—Ç–µ–ª—å"),
			})
		}
	}

	// 2. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º–∏ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è–º–∏-—Ñ–∏–∑–ª–∏—Ü–∞–º–∏
	commonFounderCompanies, err := r.CompanyService.GetCompaniesWithCommonFounders(ctx, obj.Ogrn, l/3, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonFounderCompanies {
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonFounders,
				Description:      stringPtr("–û–±—â–∏–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏-—Ñ–∏–∑–ª–∏—Ü–∞"),
			})
		}
	}

	// 3. –ü–æ–ª—É—á–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏ (–≥–¥–µ –¥–∞–Ω–Ω–∞—è –∫–æ–º–ø–∞–Ω–∏—è —É—á—Ä–µ–¥–∏—Ç–µ–ª—å)
	if obj.Inn != "" {
		subsidiaryCompanies, err := r.CompanyService.GetRelatedCompanies(ctx, obj.Inn, l/3, o)
		if err != nil {
			r.Logger.Error("failed to get subsidiary companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		} else {
			for _, company := range subsidiaryCompanies {
				relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
					Company:          company,
					RelationshipType: model.RelationshipTypeSubsidiaryCompany,
					Description:      stringPtr("–î–æ—á–µ—Ä–Ω—è—è –∫–æ–º–ø–∞–Ω–∏—è"),
				})
			}
		}
	}

	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ –∑–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
	if len(relatedCompanies) > l {
		relatedCompanies = relatedCompanies[:l]
	}

	r.Logger.Info("RelatedCompanies loaded",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("count", len(relatedCompanies)),
		zap.Int("founder_companies", len(founderCompanies)),
		zap.Int("common_founder_companies", len(commonFounderCompanies)),
	)

	return relatedCompanies, nil
}
func (r *queryResolver) Company(ctx context.Context, ogrn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByOGRN(ctx, ogrn)
	if err != nil {
		r.Logger.Error("failed to get company by ogrn", zap.String("ogrn", ogrn), zap.Error(err))
		return nil, err
	}
	return company, nil
}
func (r *queryResolver) CompanyByInn(ctx context.Context, inn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get company by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return company, nil
}
func (r *queryResolver) Companies(ctx context.Context, filter *model.CompanyFilter, pagination *model.Pagination, sort *model.CompanySort) (*model.CompanyConnection, error) {
	return r.CompanyService.List(ctx, filter, pagination, sort)
}
func (r *queryResolver) SearchCompanies(ctx context.Context, query string, limit *int, offset *int) ([]*model.Company, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.Search(ctx, query, l, o)
}
func (r *queryResolver) Entrepreneur(ctx context.Context, ogrnip string) (*model.Entrepreneur, error) {
	r.Logger.Info("üîç Entrepreneur query resolver called", zap.String("ogrnip", ogrnip))

	entrepreneur, err := r.EntrepreneurService.GetByOGRNIP(ctx, ogrnip)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by ogrnip", zap.String("ogrnip", ogrnip), zap.Error(err))
		return nil, err
	}

	r.Logger.Info("‚úÖ Entrepreneur loaded successfully",
		zap.String("ogrnip", ogrnip),
		zap.String("name", entrepreneur.FirstName+" "+entrepreneur.LastName))

	return entrepreneur, nil
}
func (r *queryResolver) EntrepreneurByInn(ctx context.Context, inn string) (*model.Entrepreneur, error) {
	entrepreneur, err := r.EntrepreneurService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return entrepreneur, nil
}
func (r *queryResolver) Entrepreneurs(ctx context.Context, filter *model.EntrepreneurFilter, pagination *model.Pagination, sort *model.EntrepreneurSort) (*model.EntrepreneurConnection, error) {
	return r.EntrepreneurService.List(ctx, filter, pagination, sort)
}
func (r *queryResolver) SearchEntrepreneurs(ctx context.Context, query string, limit *int, offset *int) ([]*model.Entrepreneur, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.EntrepreneurService.Search(ctx, query, l, o)
}
func (r *queryResolver) Search(ctx context.Context, query string, limit *int) (*model.SearchResult, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	return r.SearchService.Search(ctx, query, l)
}
func (r *queryResolver) Statistics(ctx context.Context, filter *model.StatsFilter) (*model.Statistics, error) {
	return r.StatisticsService.GetStatistics(ctx, filter)
}
func (r *queryResolver) EntityHistory(ctx context.Context, entityType model.EntityType, entityID string, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	r.Logger.Info("EntityHistory resolver called - DIRECT QUERY",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Any("limit", limit),
		zap.Any("offset", offset),
	)

	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	r.Logger.Info("EntityHistory parameters",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Int("resolved_limit", l),
		zap.Int("resolved_offset", o),
	)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º CompanyService –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–π –∏ EntrepreneurService –¥–ª—è –ò–ü
	if entityType == model.EntityTypeCompany {
		history, err := r.CompanyService.GetHistory(ctx, entityID, l, o)
		if err != nil {
			r.Logger.Error("failed to get company history", zap.String("entityID", entityID), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("EntityHistory loaded for company",
			zap.String("entityID", entityID),
			zap.Int("count", len(history)),
			zap.String("first_grn", func() string {
				if len(history) > 0 {
					return history[0].Grn
				}
				return "none"
			}()),
			zap.String("last_grn", func() string {
				if len(history) > 0 {
					return history[len(history)-1].Grn
				}
				return "none"
			}()),
		)
		return history, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistory(ctx, entityID, l, o)
	}
	return nil, fmt.Errorf("unsupported entity type: %v", entityType)
}
func (r *queryResolver) EntityHistoryCount(ctx context.Context, entityType model.EntityType, entityID string) (int, error) {
	r.Logger.Info("EntityHistoryCount resolver called - DIRECT QUERY",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
	)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º CompanyService –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–π –∏ EntrepreneurService –¥–ª—è –ò–ü
	if entityType == model.EntityTypeCompany {
		count, err := r.CompanyService.GetHistoryCount(ctx, entityID)
		if err != nil {
			r.Logger.Error("failed to get company history count", zap.String("entityID", entityID), zap.Error(err))
			return 0, err
		}
		r.Logger.Info("EntityHistoryCount loaded for company",
			zap.String("entityID", entityID),
			zap.Int("count", count),
		)
		return count, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistoryCount(ctx, entityID)
	}
	return 0, fmt.Errorf("unsupported entity type: %v", entityType)
}
func (r *queryResolver) CompanyFounders(ctx context.Context, ogrn string, limit *int, offset *int) ([]*model.Founder, error) {
	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetFounders(ctx, ogrn, l, o)
}
func (r *queryResolver) RelatedCompanies(ctx context.Context, inn string, limit *int, offset *int) ([]*model.Company, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetRelatedCompanies(ctx, inn, l, o)
}
func (r *Resolver) Company() generated.CompanyResolver { return &companyResolver{r} }
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }
*/
