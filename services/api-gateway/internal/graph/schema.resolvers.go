package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/egrul-system/services/api-gateway/internal/graph/generated"
	"github.com/egrul-system/services/api-gateway/internal/graph/model"
)

// Founders is the resolver for the founders field on Company.
func (r *companyResolver) Founders(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.Founder, error) {
	r.Logger.Info("Founders resolver called", zap.String("ogrn", obj.Ogrn))

	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	// –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å DataLoader (per-request cache)
	if loader := foundersLoaderFromContext(ctx); loader != nil {
		founders, err := loader.Load(ctx, obj.Ogrn, l, o)
		if err != nil {
			r.Logger.Error("failed to get founders via dataloader", zap.String("ogrn", obj.Ogrn), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("Founders loaded via dataloader", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
		return founders, nil
	}

	// Fallback –∫ –ø—Ä—è–º–æ–º—É –≤—ã–∑–æ–≤—É —Å–µ—Ä–≤–∏—Å–∞
	founders, err := r.CompanyService.GetFounders(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	r.Logger.Info("Founders loaded directly", zap.String("ogrn", obj.Ogrn), zap.Int("count", len(founders)))
	return founders, nil
}

// Licenses is the resolver for the licenses field on Company.
func (r *companyResolver) Licenses(ctx context.Context, obj *model.Company) ([]*model.License, error) {
	licenses, err := r.CompanyService.GetLicenses(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get licenses", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return licenses, nil
}

// Branches is the resolver for the branches field on Company.
func (r *companyResolver) Branches(ctx context.Context, obj *model.Company) ([]*model.Branch, error) {
	branches, err := r.CompanyService.GetBranches(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get branches", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}
	return branches, nil
}

// History is the resolver for the history field on Company.
func (r *companyResolver) History(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	// –ü–æ–ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ GraphQL –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
	fc := graphql.GetFieldContext(ctx)
	var l, o int = 50, 0

	r.Logger.Error("üî• CRITICAL DEBUG - History resolver called",
		zap.String("ogrn", obj.Ogrn),
		zap.Any("limit_ptr", limit),
		zap.Any("offset_ptr", offset),
		zap.Bool("limit_is_nil", limit == nil),
		zap.Bool("offset_is_nil", offset == nil),
		zap.Any("field_context", fc),
	)

	// –ü—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ GraphQL
	if fc != nil && fc.Args != nil {
		r.Logger.Info("üîç Checking GraphQL field context args", zap.Any("args", fc.Args))

		if limitArg, ok := fc.Args["limit"]; ok && limitArg != nil {
			if limitPtr, ok := limitArg.(*int); ok && limitPtr != nil {
				l = *limitPtr
				r.Logger.Info("‚úÖ Extracted limit from GraphQL context", zap.Int("limit", l))
			}
		}

		if offsetArg, ok := fc.Args["offset"]; ok && offsetArg != nil {
			if offsetPtr, ok := offsetArg.(*int); ok && offsetPtr != nil {
				o = *offsetPtr
				r.Logger.Info("‚úÖ Extracted offset from GraphQL context", zap.Int("offset", o))
			}
		}
	}

	// Fallback –∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º —Ñ—É–Ω–∫—Ü–∏–∏
	if limit != nil {
		l = *limit
		r.Logger.Info("‚úÖ Using limit from function parameter", zap.Int("limit", l))
	}

	if offset != nil {
		o = *offset
		r.Logger.Info("‚úÖ Using offset from function parameter", zap.Int("offset", o))
	}

	r.Logger.Info("üîç Final parameters for CompanyService.GetHistory",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("final_limit", l),
		zap.Int("final_offset", o))

	history, err := r.CompanyService.GetHistory(ctx, obj.Ogrn, l, o)
	if err != nil {
		r.Logger.Error("failed to get history", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return nil, err
	}

	r.Logger.Info("üìä History loaded successfully",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("requested_limit", l),
		zap.Int("requested_offset", o),
		zap.Int("returned_count", len(history)),
		zap.String("first_grn", func() string {
			if len(history) > 0 {
				return history[0].Grn
			}
			return "none"
		}()),
		zap.String("last_grn", func() string {
			if len(history) > 0 {
				return history[len(history)-1].Grn
			}
			return "none"
		}()),
	)
	return history, nil
}

// HistoryCount is the resolver for the historyCount field on Company.
func (r *companyResolver) HistoryCount(ctx context.Context, obj *model.Company) (int, error) {
	r.Logger.Info("HistoryCount resolver called", zap.String("ogrn", obj.Ogrn))

	count, err := r.CompanyService.GetHistoryCount(ctx, obj.Ogrn)
	if err != nil {
		r.Logger.Error("failed to get history count", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		return 0, err
	}
	r.Logger.Info("HistoryCount loaded", zap.String("ogrn", obj.Ogrn), zap.Int("count", count))
	return count, nil
}

// RelatedCompanies is the resolver for the relatedCompanies field on Company.
func (r *companyResolver) RelatedCompanies(ctx context.Context, obj *model.Company, limit *int, offset *int) ([]*model.RelatedCompany, error) {
	r.Logger.Info("RelatedCompanies resolver called", zap.String("ogrn", obj.Ogrn))

	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	var relatedCompanies []*model.RelatedCompany

	// 1. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏-—É—á—Ä–µ–¥–∏—Ç–µ–ª–∏ (—é—Ä–∏–¥–∏—á–µ—Å–∫–∏–µ –ª–∏—Ü–∞ –≤ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è—Ö)
	founderCompanies, err := r.CompanyService.GetFounderCompanies(ctx, obj.Ogrn, l/3, o)
	if err != nil {
		r.Logger.Error("failed to get founder companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range founderCompanies {
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeFounderCompany,
				Description:      stringPtr("–ö–æ–º–ø–∞–Ω–∏—è-—É—á—Ä–µ–¥–∏—Ç–µ–ª—å"),
			})
		}
	}

	// 2. –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–Ω–∏–∏ —Å –æ–±—â–∏–º–∏ —É—á—Ä–µ–¥–∏—Ç–µ–ª—è–º–∏-—Ñ–∏–∑–ª–∏—Ü–∞–º–∏
	commonFounderCompanies, err := r.CompanyService.GetCompaniesWithCommonFounders(ctx, obj.Ogrn, l/3, o)
	if err != nil {
		r.Logger.Error("failed to get companies with common founders", zap.String("ogrn", obj.Ogrn), zap.Error(err))
	} else {
		for _, company := range commonFounderCompanies {
			relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
				Company:          company,
				RelationshipType: model.RelationshipTypeCommonFounders,
				Description:      stringPtr("–û–±—â–∏–µ —É—á—Ä–µ–¥–∏—Ç–µ–ª–∏-—Ñ–∏–∑–ª–∏—Ü–∞"),
			})
		}
	}

	// 3. –ü–æ–ª—É—á–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏ (–≥–¥–µ –¥–∞–Ω–Ω–∞—è –∫–æ–º–ø–∞–Ω–∏—è —É—á—Ä–µ–¥–∏—Ç–µ–ª—å)
	if obj.Inn != "" {
		subsidiaryCompanies, err := r.CompanyService.GetRelatedCompanies(ctx, obj.Inn, l/3, o)
		if err != nil {
			r.Logger.Error("failed to get subsidiary companies", zap.String("ogrn", obj.Ogrn), zap.Error(err))
		} else {
			for _, company := range subsidiaryCompanies {
				relatedCompanies = append(relatedCompanies, &model.RelatedCompany{
					Company:          company,
					RelationshipType: model.RelationshipTypeSubsidiaryCompany,
					Description:      stringPtr("–î–æ—á–µ—Ä–Ω—è—è –∫–æ–º–ø–∞–Ω–∏—è"),
				})
			}
		}
	}

	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ –∑–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
	if len(relatedCompanies) > l {
		relatedCompanies = relatedCompanies[:l]
	}

	r.Logger.Info("RelatedCompanies loaded",
		zap.String("ogrn", obj.Ogrn),
		zap.Int("count", len(relatedCompanies)),
		zap.Int("founder_companies", len(founderCompanies)),
		zap.Int("common_founder_companies", len(commonFounderCompanies)),
	)

	return relatedCompanies, nil
}

// Licenses is the resolver for the licenses field on Entrepreneur.
func (r *entrepreneurResolver) Licenses(ctx context.Context, obj *model.Entrepreneur) ([]*model.License, error) {
	licenses, err := r.EntrepreneurService.GetLicenses(ctx, obj.Ogrnip)
	if err != nil {
		r.Logger.Error("failed to get licenses", zap.String("ogrnip", obj.Ogrnip), zap.Error(err))
		return nil, err
	}
	return licenses, nil
}

// History is the resolver for the history field on Entrepreneur.
func (r *entrepreneurResolver) History(ctx context.Context, obj *model.Entrepreneur, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	history, err := r.EntrepreneurService.GetHistory(ctx, obj.Ogrnip, l, o)
	if err != nil {
		r.Logger.Error("failed to get history", zap.String("ogrnip", obj.Ogrnip), zap.Error(err))
		return nil, err
	}
	return history, nil
}

// HistoryCount is the resolver for the historyCount field on Entrepreneur.
func (r *entrepreneurResolver) HistoryCount(ctx context.Context, obj *model.Entrepreneur) (int, error) {
	r.Logger.Info("HistoryCount resolver called", zap.String("ogrnip", obj.Ogrnip))

	count, err := r.EntrepreneurService.GetHistoryCount(ctx, obj.Ogrnip)
	if err != nil {
		r.Logger.Error("failed to get history count", zap.String("ogrnip", obj.Ogrnip), zap.Error(err))
		return 0, err
	}
	r.Logger.Info("HistoryCount loaded", zap.String("ogrnip", obj.Ogrnip), zap.Int("count", count))
	return count, nil
}

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context, ogrn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByOGRN(ctx, ogrn)
	if err != nil {
		r.Logger.Error("failed to get company by ogrn", zap.String("ogrn", ogrn), zap.Error(err))
		return nil, err
	}
	return company, nil
}

// CompanyByInn is the resolver for the companyByInn field.
func (r *queryResolver) CompanyByInn(ctx context.Context, inn string) (*model.Company, error) {
	company, err := r.CompanyService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get company by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return company, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, filter *model.CompanyFilter, pagination *model.Pagination, sort *model.CompanySort) (*model.CompanyConnection, error) {
	return r.CompanyService.List(ctx, filter, pagination, sort)
}

// SearchCompanies is the resolver for the searchCompanies field.
func (r *queryResolver) SearchCompanies(ctx context.Context, query string, limit *int, offset *int) ([]*model.Company, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.Search(ctx, query, l, o)
}

// Entrepreneur is the resolver for the entrepreneur field.
func (r *queryResolver) Entrepreneur(ctx context.Context, ogrnip string) (*model.Entrepreneur, error) {
	entrepreneur, err := r.EntrepreneurService.GetByOGRNIP(ctx, ogrnip)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by ogrnip", zap.String("ogrnip", ogrnip), zap.Error(err))
		return nil, err
	}
	return entrepreneur, nil
}

// EntrepreneurByInn is the resolver for the entrepreneurByInn field.
func (r *queryResolver) EntrepreneurByInn(ctx context.Context, inn string) (*model.Entrepreneur, error) {
	entrepreneur, err := r.EntrepreneurService.GetByINN(ctx, inn)
	if err != nil {
		r.Logger.Error("failed to get entrepreneur by inn", zap.String("inn", inn), zap.Error(err))
		return nil, err
	}
	return entrepreneur, nil
}

// Entrepreneurs is the resolver for the entrepreneurs field.
func (r *queryResolver) Entrepreneurs(ctx context.Context, filter *model.EntrepreneurFilter, pagination *model.Pagination, sort *model.EntrepreneurSort) (*model.EntrepreneurConnection, error) {
	return r.EntrepreneurService.List(ctx, filter, pagination, sort)
}

// SearchEntrepreneurs is the resolver for the searchEntrepreneurs field.
func (r *queryResolver) SearchEntrepreneurs(ctx context.Context, query string, limit *int, offset *int) ([]*model.Entrepreneur, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.EntrepreneurService.Search(ctx, query, l, o)
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, limit *int) (*model.SearchResult, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	return r.SearchService.Search(ctx, query, l)
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context, filter *model.StatsFilter) (*model.Statistics, error) {
	return r.StatisticsService.GetStatistics(ctx, filter)
}

// EntityHistory is the resolver for the entityHistory field.
func (r *queryResolver) EntityHistory(ctx context.Context, entityType model.EntityType, entityID string, limit *int, offset *int) ([]*model.HistoryRecord, error) {
	r.Logger.Info("EntityHistory resolver called - DIRECT QUERY",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Any("limit", limit),
		zap.Any("offset", offset),
	)

	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	r.Logger.Info("EntityHistory parameters",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
		zap.Int("resolved_limit", l),
		zap.Int("resolved_offset", o),
	)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º CompanyService –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–π –∏ EntrepreneurService –¥–ª—è –ò–ü
	if entityType == model.EntityTypeCompany {
		history, err := r.CompanyService.GetHistory(ctx, entityID, l, o)
		if err != nil {
			r.Logger.Error("failed to get company history", zap.String("entityID", entityID), zap.Error(err))
			return nil, err
		}
		r.Logger.Info("EntityHistory loaded for company",
			zap.String("entityID", entityID),
			zap.Int("count", len(history)),
			zap.String("first_grn", func() string {
				if len(history) > 0 {
					return history[0].Grn
				}
				return "none"
			}()),
			zap.String("last_grn", func() string {
				if len(history) > 0 {
					return history[len(history)-1].Grn
				}
				return "none"
			}()),
		)
		return history, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistory(ctx, entityID, l, o)
	}
	return nil, fmt.Errorf("unsupported entity type: %v", entityType)
}

// EntityHistoryCount is the resolver for the entityHistoryCount field.
func (r *queryResolver) EntityHistoryCount(ctx context.Context, entityType model.EntityType, entityID string) (int, error) {
	r.Logger.Info("EntityHistoryCount resolver called - DIRECT QUERY",
		zap.String("entityType", string(entityType)),
		zap.String("entityID", entityID),
	)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º CompanyService –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–π –∏ EntrepreneurService –¥–ª—è –ò–ü
	if entityType == model.EntityTypeCompany {
		count, err := r.CompanyService.GetHistoryCount(ctx, entityID)
		if err != nil {
			r.Logger.Error("failed to get company history count", zap.String("entityID", entityID), zap.Error(err))
			return 0, err
		}
		r.Logger.Info("EntityHistoryCount loaded for company",
			zap.String("entityID", entityID),
			zap.Int("count", count),
		)
		return count, nil
	} else if entityType == model.EntityTypeEntrepreneur {
		return r.EntrepreneurService.GetHistoryCount(ctx, entityID)
	}
	return 0, fmt.Errorf("unsupported entity type: %v", entityType)
}

// CompanyFounders is the resolver for the companyFounders field.
func (r *queryResolver) CompanyFounders(ctx context.Context, ogrn string, limit *int, offset *int) ([]*model.Founder, error) {
	l := 100
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetFounders(ctx, ogrn, l, o)
}

// RelatedCompanies is the resolver for the relatedCompanies field.
func (r *queryResolver) RelatedCompanies(ctx context.Context, inn string, limit *int, offset *int) ([]*model.Company, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	return r.CompanyService.GetRelatedCompanies(ctx, inn, l, o)
}

// Company returns generated.CompanyResolver implementation.
func (r *Resolver) Company() generated.CompanyResolver { return &companyResolver{r} }

// Entrepreneur returns generated.EntrepreneurResolver implementation.
func (r *Resolver) Entrepreneur() generated.EntrepreneurResolver { return &entrepreneurResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type companyResolver struct{ *Resolver }
type entrepreneurResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
