package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/egrul-system/services/api-gateway/internal/auth"
	"github.com/egrul-system/services/api-gateway/internal/graph/model"
	"github.com/egrul-system/services/api-gateway/internal/repository/postgresql"
	"go.uber.org/zap"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	if r.UserRepo == nil {
		return nil, fmt.Errorf("user repository not configured")
	}
	if r.JWTManager == nil {
		return nil, fmt.Errorf("JWT manager not configured")
	}

	// Проверяем, существует ли пользователь с таким email
	existingUser, err := r.UserRepo.GetByEmail(ctx, input.Email)
	if err != nil {
		r.Logger.Error("failed to check user existence", zap.Error(err), zap.String("email", input.Email))
		return nil, fmt.Errorf("failed to check user existence: %w", err)
	}

	if existingUser != nil {
		return nil, errors.New("user with this email already exists")
	}

	// Хешируем пароль
	passwordHash, err := auth.HashPassword(input.Password)
	if err != nil {
		r.Logger.Error("failed to hash password", zap.Error(err))
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Создаем пользователя
	user := &postgresql.User{
		Email:         input.Email,
		PasswordHash:  passwordHash,
		FirstName:     input.FirstName,
		LastName:      input.LastName,
		IsActive:      true,
		EmailVerified: false, // Требуется email verification
	}

	if err := r.UserRepo.Create(ctx, user); err != nil {
		r.Logger.Error("failed to create user", zap.Error(err), zap.String("email", input.Email))
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Генерируем JWT токен
	token, err := r.JWTManager.Generate(user.ID, user.Email)
	if err != nil {
		r.Logger.Error("failed to generate JWT token", zap.Error(err), zap.String("user_id", user.ID))
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	expiresAt := time.Now().Add(24 * time.Hour) // TODO: получать из конфига

	r.Logger.Info("user registered successfully",
		zap.String("user_id", user.ID),
		zap.String("email", user.Email),
	)

	// Преобразуем в GraphQL модель
	gqlUser := &model.User{
		ID:            user.ID,
		Email:         user.Email,
		FirstName:     user.FirstName,
		LastName:      user.LastName,
		IsActive:      user.IsActive,
		EmailVerified: user.EmailVerified,
		CreatedAt:     user.CreatedAt,
		UpdatedAt:     user.UpdatedAt,
		LastLoginAt:   user.LastLoginAt,
	}

	return &model.AuthResponse{
		User:      gqlUser,
		Token:     token,
		ExpiresAt: expiresAt,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	if r.UserRepo == nil {
		return nil, fmt.Errorf("user repository not configured")
	}
	if r.JWTManager == nil {
		return nil, fmt.Errorf("JWT manager not configured")
	}

	// Получаем пользователя по email
	user, err := r.UserRepo.GetByEmail(ctx, input.Email)
	if err != nil {
		r.Logger.Error("failed to get user", zap.Error(err), zap.String("email", input.Email))
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	if user == nil {
		return nil, errors.New("invalid email or password")
	}

	// Проверяем пароль
	if !auth.CheckPassword(input.Password, user.PasswordHash) {
		r.Logger.Warn("invalid password attempt", zap.String("email", input.Email))
		return nil, errors.New("invalid email or password")
	}

	// Проверяем активность аккаунта
	if !user.IsActive {
		return nil, errors.New("user account is disabled")
	}

	// Обновляем время последнего входа
	if err := r.UserRepo.UpdateLastLogin(ctx, user.ID); err != nil {
		r.Logger.Error("failed to update last login", zap.Error(err), zap.String("user_id", user.ID))
		// Не прерываем процесс входа из-за ошибки обновления
	}

	// Генерируем JWT токен
	token, err := r.JWTManager.Generate(user.ID, user.Email)
	if err != nil {
		r.Logger.Error("failed to generate JWT token", zap.Error(err), zap.String("user_id", user.ID))
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	expiresAt := time.Now().Add(24 * time.Hour) // TODO: получать из конфига

	r.Logger.Info("user logged in successfully",
		zap.String("user_id", user.ID),
		zap.String("email", user.Email),
	)

	// Преобразуем в GraphQL модель
	gqlUser := &model.User{
		ID:            user.ID,
		Email:         user.Email,
		FirstName:     user.FirstName,
		LastName:      user.LastName,
		IsActive:      user.IsActive,
		EmailVerified: user.EmailVerified,
		CreatedAt:     user.CreatedAt,
		UpdatedAt:     user.UpdatedAt,
		LastLoginAt:   user.LastLoginAt,
	}

	return &model.AuthResponse{
		User:      gqlUser,
		Token:     token,
		ExpiresAt: expiresAt,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// В случае stateless JWT токенов, logout происходит на клиенте
	// (удаление токена из localStorage)
	// Здесь можно добавить blacklist токенов при необходимости
	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	if r.UserRepo == nil {
		return nil, fmt.Errorf("user repository not configured")
	}

	// Извлекаем userID из контекста (добавлен JWT middleware)
	userID := auth.GetUserIDFromContext(ctx)

	// Получаем пользователя из БД
	user, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		r.Logger.Error("failed to get user", zap.Error(err), zap.String("user_id", userID))
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	if user == nil {
		return nil, errors.New("user not found")
	}

	// Преобразуем в GraphQL модель
	gqlUser := &model.User{
		ID:            user.ID,
		Email:         user.Email,
		FirstName:     user.FirstName,
		LastName:      user.LastName,
		IsActive:      user.IsActive,
		EmailVerified: user.EmailVerified,
		CreatedAt:     user.CreatedAt,
		UpdatedAt:     user.UpdatedAt,
		LastLoginAt:   user.LastLoginAt,
	}

	return gqlUser, nil
}
